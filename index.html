<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Technical page</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
<link href="https://fonts.googleapis.com/css2?family=Space+Mono&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
  </head>
  <body>
    <nav id="navbar">
      <h2 class="title">Documentation</h2>
      <header class="title">Node.js</header>
      <ul class="ul">
      <li><a class="nav-link" href="#Introduction">Introduction</a></li>
      <li><a class="nav-link" href="#Overview">Overview</a></li>
      <li><a class="nav-link" href="#History">History</a></li>
      <li><a class="nav-link" href="#Technical-Detail">Technical-Detail</a></li>
      <li><a class="nav-link" href="#Referance">Referance</a></li>
        </ul>
      </nav>
<main id="main-doc">
<section id="Introduction" class="main-section">
<header>Introduction</header>
<article>
  <p><em><strong>Node.js</strong></em> is an open-source, cross-platform, back-end JavaScript runtime environment that runs on the V8 engine and executes JavaScript code outside a web browser. Node.js lets developers use JavaScript to write command line tools and for server-side scripting—running scripts server-side to produce dynamic web page content before the page is sent to the user's web browser. Consequently, Node.js represents a "JavaScript everywhere" paradigm,[6] unifying web-application development around a single programming language, rather than different languages for server-side and client-side scripts.</p>
  <p>Though .js is the standard filename extension for JavaScript code, the name "Node.js" doesn't refer to a particular file in this context and is merely the name of the product. Node.js has an event-driven architecture capable of asynchronous I/O. These design choices aim to optimize throughput and scalability in web applications with many input/output operations, as well as for real-time Web applications (e.g., real-time communication programs and browser games).[7]

The Node.js distributed development project was previously governed by the Node.js Foundation,[8] and has now merged with the JS Foundation to form the OpenJS Foundation, which is facilitated by the Linux Foundation's Collaborative Projects program.[9]</p>
  </article>
</section>

    <section id="Overview" class="main-section">
<header>Overview</header>
<article>
  <p><em>Node.js</em> allows the creation of Web servers and networking tools using JavaScript and a collection of "modules" that handle various core functionalities.[29][32][46][47][48] Modules are provided for file system I/O, networking (DNS, HTTP, TCP, TLS/SSL, or UDP), binary data (buffers), cryptography functions, data streams, and other core functions.[32][47][49] Node.js's modules use an API designed to reduce the complexity of writing server applications.[32][47]</p>
  <p>Node.js is primarily used to build network programs such as Web servers.[46] The most significant difference between Node.js and PHP is that most functions in PHP block until completion (commands execute only after previous commands finish), while Node.js functions are non-blocking (commands execute concurrently or even in parallel,[52][53] and use callbacks to signal completion or failure).[46]</p>
  <ul>
    <li><strong>Platform architecture</strong></li>
    <p><code>>Node.js brings event-driven programming to web servers,</code> enabling development of fast web servers in JavaScript.[32] Developers can create scalable servers without using threading, by using a simplified model of event-driven programming that uses callbacks to signal the completion of a task.[32] Node.js connects the ease of a scripting language (JavaScript) with the power of Unix network programming.[32]

    Node.js was built on top of Google's V8 JavaScript engine since it was open-sourced under the BSD license. It is proficient with internet fundamentals such as HTTP, DNS, and TCP.[29] JavaScript was also a well-known language, making Node.js accessible to the web development community.[29]</p>
<li><strong>Industry support</strong></li>
<p><code>There are thousands of open-source libraries for Node.js, most of them hosted on the npm website.</code> There are multiple developer conferences and events that support the Node.js community, including NodeConf, Node Interactive, and Node Summit as well as a number of regional events.

The open-source community has developed web frameworks to accelerate the development of applications. Such frameworks include Connect, Express.js, Socket.IO, Feathers.js, Koa.js, Hapi.js, Sails.js, Meteor, Derby, and many others.[32][56] Various packages have also been created for interfacing with other languages or runtime environments such as Microsoft .NET.[57]

Modern desktop IDEs provide editing and debugging features specifically for Node.js applications. Such IDEs include Atom, Brackets, JetBrains WebStorm,[58][59] Microsoft Visual Studio (with Node.js Tools for Visual Studio,[60] or TypeScript with Node definitions,[61][62][63][64]) NetBeans,[65] Nodeclipse Enide Studio[66] (Eclipse-based), and Visual Studio Code.[67][68] Certain online web-based IDEs also support Node.js, such as Codeanywhere, Codenvy, Cloud9 IDE, Koding, and the visual flow editor in Node-RED.</p>
    </ul>
  </article>
    </section>

    <section id="History" class="main-section">
<header>History</header>
<article>
  <p>
    <em>Node.js</em> was written initially by Ryan Dahl in 2009,[25] about thirteen years after the introduction of the first server-side JavaScript environment, Netscape's LiveWire Pro Web.[26] The initial release supported only Linux and Mac OS X. Its development and maintenance was led by Dahl and later sponsored by Joyent.[27]

Dahl criticized the limited possibilities of the most popular web server in 2009, Apache HTTP Server, to handle a lot of concurrent connections (up to 10,000 and more) and the most common way of creating code (sequential programming), when code either blocked the entire process or implied multiple execution stacks in the case of simultaneous connections.[28]

Dahl demonstrated the project at the inaugural European JSConf on November 8, 2009.[29][30][31] Node.js combined Google's V8 JavaScript engine, an event loop, and a low-level I/O API.[32]
    </p>
    <p>
      In January 2010, a package manager was introduced for the Node.js environment called npm.[33] The package manager makes it easier for programmers to publish and share source code of Node.js packages and is designed to simplify installation, updating, and uninstallation of packages.[32]

In June 2011, Microsoft and Joyent implemented a native Windows version of Node.js.[34] The first Node.js build supporting Windows was released in July 2011.

In January 2012, Dahl stepped aside, promoting coworker and npm creator Isaac Schlueter to manage the project.[35] In January 2014, Schlueter announced that Timothy J. Fontaine would lead the project.[36]

In December 2014, Fedor Indutny started io.js, a fork of Node.js. Due to the internal conflict over Joyent's governance, io.js was created as an open governance alternative with a separate technical committee.[37][38] Unlike Node.js,[39] the authors planned to keep io.js up-to-date with the latest releases of the Google V8 JavaScript engine.[40]

In February 2015, the intent to form a neutral Node.js Foundation was announced. By June 2015, the Node.js and io.js communities voted to work together under the Node.js Foundation.[41]

In September 2015, Node.js v0.12 and io.js v3.3 were merged back together into Node v4.0.[42] This merge brought V8 ES6 features into Node.js and a long-term support release cycle.[43] As of 2016, the io.js website recommends that developers switch back to Node.js and that no further releases of io.js are planned due to the merge.[44]

In February 2016, Node.js 0.10.42 is released.[45]
      </p>
  </article>
      </section>

      <section id="Technical-Detail" class="main-section">
<header>Technical-Detail</header>
<article>
  <p>
    <em>Node.js</em> is a JavaScript runtime environment that processes incoming requests in a loop, called the event loop.
    </p>
    <ul>
      <li><strong>Internals</strong></li>
      <p>
        <code>Node.js uses libuv underhood to handle asynchronous events.</code> Libuv is an abstraction layer for network and file system functionality on both Windows and POSIX-based systems such as Linux, macOS, OSS on NonStop, and Unix.
        </p>
        <li><strong>Threading</strong></li>
        <p>
          <code>Node.js operates on a single-thread event loop, using non-blocking I/O calls,</code> allowing it to support tens of thousands of concurrent connections without incurring the cost of thread context switching.[70] The design of sharing a single thread among all the requests that use the observer pattern is intended for building highly concurrent applications, where any function performing I/O must use a callback. To accommodate the single-threaded event loop, Node.js uses the libuv library—which, in turn, uses a fixed-sized thread pool that handles some of the non-blocking asynchronous I/O operations.[7]
          </p>
        <p>
          A thread pool handles the execution of parallel tasks in Node.js. The main thread function call posts tasks to the shared task queue, which threads in the thread pool pull and execute. Inherently non-blocking system functions such as networking translate to kernel-side non-blocking sockets, while inherently blocking system functions such as file I/O run in a blocking way on their own threads. When a thread in the thread pool completes a task, it informs the main thread of this, which in turn, wakes up and executes the registered callback.
          </p>
          <li><strong>V8</strong></li>
          <p>
            <code>V8 is the JavaScript execution engine which was initially built for Google Chrome.</code> It was then open-sourced by Google in 2008. Written in C++, V8 compiles JavaScript source code to native machine code at runtime. [7] As of 2016, it also includes Ignition, a bytecode interpreter.
            </p>
            <li><strong>Unified API</strong></li>
            <p>
              <code>Node.js can be combined with a browser,</code> a database that supports JSON data (such as Postgres,[74] MongoDB, or CouchDB) and JSON for a unified JavaScript development stack. With the adaptation of what were essentially server-side development patterns such as MVC, MVP, MVVM, etc., Node.js allows the reuse of the same model and service interface between client side and server side.
              </p>
              <li><strong>Event loop</strong></li>
              <p>
                <code>Node.js registers with the operating system so the OS notifies it of connections and issues a callback.</code> Within the Node.js runtime, each connection is a small heap allocation. Traditionally, relatively heavyweight OS processes or threads handled each connection. Node.js uses an event loop for scalability, instead of processes or threads.[75] In contrast to other event-driven servers, Node.js's event loop does not need to be called explicitly. Instead, callbacks are defined, and the server automatically enters the event loop at the end of the callback definition. Node.js exits the event loop when there are no further callbacks to be performed.
                </p>
                <li><strong>WebAssembly</strong></li>
                <p>
                  <code>Node.js supports WebAssembly and as of Node 14 has experimental support of WASI, the WebAssembly System Interface.</code>
                  </p>
                  <li><strong>Native bindings</strong></li>
                  <p>
                    <code>Node.js provides a way to make "addons" via a C-based API called N-API which can be used to produce loadable (importable) .node modules from source code written in C/C++.[76]</code> The modules can be directly loaded into memory and executed from within JS environment as simple CommonJS modules. The implementation of the N-API relies on internal C/C++ Node.js and V8 objects requiring users to import (#include) Node.js specific headers into their native source code.[76] As Node.js platform constantly evolves the API compatibility is subject to changes and may get broken sometimes by a new version (as consequence modules have to be built against specific Node.js versions to work correctly). To address the issue third parties have introduced open-sourced С/С++ wrappers on top of the API that partially alleviate the problem. They simplify interfaces but as side effect they may also introduce complexity which maintainers have to deal with. Even though the core functionality of Node.js resides in a JavaScript built-in library, modules written in C++ can be used to enhance capabilities and to improve performance of applications.

In order to produce such modules one needs to have an appropriate C++ compiler and necessary headers (the latter are typically shipped with Node.js itself): gcc, clang or MSVC++.

The N-API is similar to Java Native Interface.
                    </p>
      </ul>
  </article>
        </section>

        <section id="Referance"class="main-section">
<header>Referance</header>
<ul>
  <li>
    All the information in this page is taken from <a target="_blank"href="https://en.wikipedia.org/wiki/Node.js#Project_governance">Wikipedia</a>
    </li>
  </ul>
          </section>

  </main>
<script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
</body>
</html>
